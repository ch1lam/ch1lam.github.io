<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>精读《对前端架构的理解-分层与抽象》</title>
    <link href="/2022/08/31/%E7%B2%BE%E8%AF%BB%E3%80%8A%E5%AF%B9%E5%89%8D%E7%AB%AF%E6%9E%B6%E6%9E%84%E7%9A%84%E7%90%86%E8%A7%A3-%E5%88%86%E5%B1%82%E4%B8%8E%E6%8A%BD%E8%B1%A1%E3%80%8B/"/>
    <url>/2022/08/31/%E7%B2%BE%E8%AF%BB%E3%80%8A%E5%AF%B9%E5%89%8D%E7%AB%AF%E6%9E%B6%E6%9E%84%E7%9A%84%E7%90%86%E8%A7%A3-%E5%88%86%E5%B1%82%E4%B8%8E%E6%8A%BD%E8%B1%A1%E3%80%8B/</url>
    
    <content type="html"><![CDATA[<p>从计算机与操作系统的架构设计出发，探讨了前端架构设计的必要性，并从分层与抽象两个角度分析了架构设计时的考量</p><span id="more"></span><blockquote><p>原文转自 <ahref="https://github.com/ascoders/weekly/blob/master/%E5%89%8D%E6%B2%BF%E6%8A%80%E6%9C%AF/254.%E7%B2%BE%E8%AF%BB%E3%80%8A%E5%AF%B9%E5%89%8D%E7%AB%AF%E6%9E%B6%E6%9E%84%E7%9A%84%E7%90%86%E8%A7%A3%20-%20%E5%88%86%E5%B1%82%E4%B8%8E%E6%8A%BD%E8%B1%A1%E3%80%8B.md">ascoders/weekly- 254.精读《对前端架构的理解 - 分层与抽象》</a></p></blockquote><p>可能一些同学会认为前端比较简单而不需要架构，或者因为前端交互细节杂而乱难以统一抽象，所以没办法进行架构设计。这个理解是片面的，虽然一些前端项目是没有仔细考虑架构就堆起来的，但这不代表不需要架构设计。任何业务程序都可以通过代码堆砌的方式实现功能，但背后的可维护性、可拓展性自然也就千差万别了。</p><p>为什么前端项目也要考虑架构设计？有如下几点原因：</p><ul><li><strong>从必要性看</strong>，前后端应用都跑在计算机上，计算机从硬件到操作系统，再到上层库都是有清晰架构设计与分层的，应用程序作为最上层的一环也是嵌入在整个大架构图里的。</li><li><strong>从可行性看</strong>，交互虽然多而杂，但这不构成不需要架构设计的理由。对计算机基础设计来说，也面临着多种多样的输入设备与输出设备，进而产生的标准输入输出的抽象，那么前端也应当如此。</li><li><strong>从广义角度看</strong>，大部分通用的约定与模型早已沉淀下来了，如编程语言，前端框架本身就是业务架构的一部分，用React 哪怕写个 “Hello World” 也使用了数据驱动的设计理念。</li></ul><p><strong>从必要性看</strong>，虽然操作系统和各类基础库屏蔽了底层实现，让业务可以仅关心业务逻辑，大大解放了生产力，但一款应用必然是底层操作系统与业务层代码协同才能运行的，从应用程序往下有一套逻辑井然的架构分层设计，如果到了业务层没有很好的架构设计，技术抽象是一团乱麻，很难想象这样形成的整体运行环境是健康的。</p><p>业务模块的架构设计应当类似计算机基础的架构设计，从需求分析出发，设计有哪些业务子模块，并定义这些子模块的职责与子模块之间的关系。子模块的设计取决于业务的特性，子模块间的分层取决于业务的拓展能力。</p><p>比如一个绘图软件设计时只要需要组件子系统与布局子系统，它们之间互相独立，也能无缝结合。对于BI软件来说，就增加了筛选联动与通用数据查询的概念，因此对应的也会增加筛选联动模型、数据模型、图形语法这几个子模块，并按照其作用关系上下分层：</p><figure><img src="系统架构图.jpg" alt="系统架构图" /><figcaption aria-hidden="true">系统架构图</figcaption></figure><p>如果分层清晰而准确，可以看出这两个业务上层具有相同的抽象，即最上层都是组件与布局的结合，而筛选联动与数据查询，以及从数据模型映射到图元关系的映射功能都属于附加项，这些项移除了也不影响系统的运行。如果不这么设计，可能就理不清系统之间的相似点与差异点，导致功能耦合，要维护一个大系统可能要时刻关系各模块之间的相互影响，这样的系统即不清晰，也不够可拓展，关键是要维护它的理解成本也高。</p><p><strong>从可行性看</strong>，前端的特点在于用户输入的触点非常多，但这不妨碍我们抽象标准输入接口，比如用户点击按钮或者输入框是输入，那键盘快捷键也是一种输入方式，URL参数也是一种输入方式，在业务前置的表单配置也是一种输入方式，如果输入方式很多，对标准输入的抽象就变得重要，使业务代码的实际复杂度不至于真的膨胀到用户使用的复杂度那么高。</p><p>不止输入触点多，前端系统的功能组合也非常多，比如图形绘制软件，画布可以放任意数量的组件，每个组件有任意多的配置，组件之间还可以相互影响。这种系统属于开放式系统，用户很容易试出开发者都未曾想到过的功能组合，有些时候开发者都惊叹这些新的组合竟然能一起工作！用户会感叹软件能力的强大，但开发者不能真的把这些功能组合一一尝试来解决冲突，必须通过合理的分层抽象来保证功能组合的稳定性。</p><p>其实这种挑战也是计算机面临的问题，如何设计一个通用架构的计算机，使上面可以运行任何开发者软件，且软件之间可以相互独立，也可以相互调用，系统还不容易产生BUG。从这个角度来看，计算机的底层架构设计对前端架构设计是有参考意义的，大体上来说，计算机通过硬件、操作系统、软件这个三个分层解决了要计算一切的难题。</p><p>冯·诺依曼体系就解决了硬件层面的问题。为了保证软件层的可拓展性，通过CPU、存储、输入输出设备的抽象解决了计算、存储、拓展的三个基本能力。再细分来看，CPU也仅仅支持了三个基本能力：数学计算、条件控制、子函数。这使得计算机底层设计既是稳定的，设计因素也是可枚举的，同时拥有了强大的拓展能力。</p><p>操作系统也一样，它不需要知道软件具体是怎么执行的，只需要给软件提供一个安全的运行环境，使软件不会受到其他软件的干扰；提供一些基本范式统一软件的行为，比如多窗口系统，防止软件同时在一块区域绘图而相互影响；提供一些基础的系统调用封装给上层的语言进行二次封装，而考虑到这些系统调用封装可能会随着需求而拓展，进而采用动态链接库的方式实现，等等。操作系统为了让自身功能稳定与可枚举，对自己与软件定义了清晰的边界，无论软件怎么拓展，操作系统不需要拓展。</p><p>回到前端业务，想要保障一个复杂的绘图软件代码清晰与好的可维护性，一样需要从最底层稳定的模块开始网上，一步步构建模块间依赖关系，只有这样，模块内逻辑才能可枚举，模块与模块间才敢大胆的组合，各自设计各自的拓展点，使整个系统最终拥有强大的拓展能力，但细看每个子模块又都是简单清晰、可枚举可测试的代码逻辑。</p><p>以 BI 系统举例，划分为组件、筛选、布局、数据模型四个子系统的话：</p><ul><li>对组件系统来说，任何组件实现都可接入，这就使这个 BI系统不仅可以展示报表，也可以展示普通的按钮，甚至表单，可以搭建任意数据产品，或者可以搭建任意的网站，能力拓展到哪完全由业务决定。</li><li>对筛选系统来说，任何组件之间都能关联，不一定是筛选器到图表，也可以是图表到图表，这样就支持了图表联动。不仅是BI联动场景，即便是做一个表单联动都可以复用这个筛选能力，使整个系统实现统一而简单。</li><li>对布局系统来说，不关心布局内的组件是什么，有哪些关联能力，只要做好布局就行。这样画布系统容易拓展为任何场景，比如生产效率工具、仪表盘、ppt或者大屏，而对其他系统无影响。</li><li>对数据模型系统来说，其承担了数据配置到 sql查询，最后映射到图形通道展示的过程，它本身是对组件系统中，统计图表类型的抽象实现，因此虽然逻辑复杂，但也不影响其他子系统的设计。</li></ul><p><strong>从广义角度看</strong>，前端业务代码早就处于一系列架构分层中，也就是编程语言与前端框架。编程语言与前端框架会自带一些设计模式，以减少混用代码范式带来的沟通成本，其实架构设计本身也要解决代码一致性问题，所以这些内容都是架构设计的一环。</p><p>前端框架带来的数据驱动特性本身就很大程度上解决了前端代码在复杂应用下可维护问题，大大降低了过程代码带来的复杂度。React或 Vue框架本身也起到了类似操作系统的操作，即定义上层组件（软件规格）的规格，为组件渲染和事件响应抹平浏览器差异（硬件差异），并提供组件渲染调度功能（软件调度）。同时也提供了组件间变量传递（进程通信），让组件与组件间通信符合统一的接口。</p><p>但是没有必要把每个组件都类比到进程来设计，也就是说，组件与组件之间不用都通过通信方式工作。比较合适的类比粒度是模块，把一个大模块抽象为组件，模块与模块间互相不依赖，用数据通信来交流。小粒度组件就做成状态无关的元件，注意相似功能的组件接口尽量保持一致，这样就能体验到类似多态的好处。</p><p>所以话说回来，遵循前端框架的代码规范不是一件可有可无的事情，业务架构设计从编程语言和前端框架时就已经开始了，如果一个组件不遵循框架的最佳实践，就无法参与到更上层的业务架构规划里，最终可能导致项目混乱，或者无架构可言。所以重视架构设计从代码规范就要开始。</p><p>所以前端架构设计是必要的，那怎么做好前端架构设计呢？这个话题太过于庞大，本次就从操作系统借鉴一些灵感，先谈一谈对分层与抽象的理解。</p><h2 id="没有绝对的分层">没有绝对的分层</h2><p>分层是架构设计的重点，但一个模块在分层的位置可能会随着业务迭代而变化，类比到操作系统举两个例子：</p><p>语音输入现在由各个软件自行提供，背后的语音识别与 NLP能力可能来自各大公司的 AI 中台，或者一些提供 AI能力的云服务。但语音输入能力成熟后，很可能会成为操作系统内置能力，因为语音输入与键盘输入都属于标准输入，只是语音输入难度更大，操作系统短期难以内置，所以目前发展在各个上层应用里。</p><p>Go语言的协程实现在编程语言层，但其对标的线程实现在操作系统层，协程运行在用户态，而线程运行在内核态。但如果哪天操作系统提供了更高效的线程，内存占用也采用动态递增的逻辑，说不定协程就不那么必要了。</p><p>按理说语音输入属于标准输入的一部分，应该实现在操作系统的通用输入层，协程也属于多任务处理的一部分，应该实现在操作系统多任务处理层，但它们都被是现在了更上层，有的在编程语言层，有的在业务服务层。之所以产生了这些意外，是因为通用输入输出层与多任务处理层的需求并没有想象中那么稳定，随着技术的迭代，需要对其拓展时，因为内置在底层不方便拓展，只能在更上层实现了。</p><p>当然我们也要注意到的是，即便这些拓展点实现在更上层，但对软件工程师来说并没有特别大的侵入性影响，比如goroutine，程序员并不接触操作系统提供的API，所以编程语言层对操作系统能力的拓展对程序员是透明的；语音输入就有一点影响了，如果由操作系统来实现，可能就变成与键盘输出保持一致的事件结构了，但由业务层实现就有无数种API 格式了，业务流程可能也更加复杂，比如增加鉴权。</p><p>从计算机操作系统的例子我们可以学习到两点：</p><ol type="1"><li>站在分层合理性视角对输入做进一步的抽象与整合。比如将语音识别封装到标准的输入事件，让其逻辑上成为标准输入层。</li><li>业务架构的设计必然也会遇到分层不满足业务拓展性的场景。</li></ol><p>业务分层与硬件、操作系统不同的是，业务分层中，几乎所有层都方便修改与拓展，因此如果遇到分层不合理的设计，最好将其移动到应该归属的层。操作系统与硬件层不方便随意拓展的原因是版本更新的频率和软件更新的频率不匹配。</p><p>同时，也要意识到分层需要一个演进过程，等新模块稳定后再移动到其归属所在层可能更好，因为从上层挪到底层意味着更多被模块共享使用，就像我们不会轻易把软件层某个包提供的函数内置到编程语言一样，也不会随意把编程语言实现的函数内置到操作系统内置的系统调用。</p><p>在前端领域的一个例子是，如果一个搭建平台项目中已经有了一套组件元信息描述，最好先让其在业务代码里跑一段时间，观察一下元信息定义的属性哪些有缺失，哪些是不必要的，等业务稳定一段时间后，再把这套元信息运行时代码抽成一个通用包提供给本业务，甚至其他业务使用。但即便这个能力沉淀到了通用包，也不代表它就是永远不能被迭代的，操作系统的多任务管理都有协程来挑战，何况前端一个抽象包的能力呢？所以要慎重抽象，但抽象后也要敢于质疑挑战。</p><h2 id="没有绝对的抽象">没有绝对的抽象</h2><p>抽象粒度永远是架构设计的难题。</p><p>计算机把一切都理解为数据。计算结果是数据，执行程序的代码也是数据，所以CPU只要专注于对数据的计算，再加上存储与输入输出，就可以完成一切工作。想一想这样抽象的伟大之处：所有程序最终对计算机来说都是这三个概念，CPU在计算时无需关心任何业务含义，这也使得它可以计算任何业务。</p><p>另一个有争议的抽象是 Unix一切皆文件的抽象，该抽象使文件、进程、线程、socket 等管理都抽象为文件的API，且都拥有特定的 “文件路径”，比如你甚至可以通过 <code>/proc</code>访问到进程文件夹，<code>ls</code>可以看到所有运行的进程。当然进程不是文件，这只是说明了 Unix的一种抽象哲学，即 “文件”本身就是一种抽象，开发和可以用理解文件的方式理解一切事物，这带来了巨大的理解成本降低，也使许多代码模式可以不关心具体资源类型。但这样做的争议点在于，并不是一切资源都适合抽象成文件，比如输入输出中的显示器，它作为一个呈现五彩缤纷像素点的载体，实在难以用文件系统来统一描述。</p><p>计算机设计与操作系统设计已经给了我们很明显的启发，即一切能抽象的都要尽可能的抽象，如此才能提高系统各模块内的稳定性。但从如Unix一切皆文件的抽象来看，有时候的技术抽象难免被当时的业务需求所局限，当输入输出设备的种类增加后，这种极致的抽象未必能永远合适。但永远要相信抽象，因为假若所有资源都可以被文件抽象所描述，且使用起来没有不便捷的地方，为什么还要造其他的抽象概念呢？如无必要勿增实体。</p><p>比如 BI场景的筛选、联动、下钻场景是否都能抽象为组件与组件间的联动关系呢？如果一套标准联动设计可以解决这三个场景，那自然不需要为某个具体场景单独引入概念。从原始场景来看，无论筛选、联动还是下钻场景都是修改组件的取数参数以改变查询条件，我们就可以抽象出一种组件间联动的规范，使其可以驱动取数参数的变化，但未来需求可能引入更多的可能性，如在筛选时触发一些额外的追加分析查询，此时之前的抽象就收到了挑战，我们需要权衡维持统一性的收益与通用接口不适用于特殊场景带来成本之间的平衡。</p><p>抽象的方式是无数的，哪种更好取决于业务如何变化，不用过于纠结完美的抽象，就连Unix一切皆文件的最基础抽象都备受争议，业务抽象的稳定性肯定会更差，也更需要随着需求变化而调整。</p><h2 id="总结">总结</h2><p>我们从计算机与操作系统的架构设计出发，探讨了前端架构设计的必要性，并从分层与抽象两个角度分析了架构设计时的考量，希望你在架构设计遇到拿捏不定的问题时，可以向下借助计算机的架构设计获得一些灵感或支持。</p><blockquote><p>讨论地址是：<ahref="https://github.com/dt-fe/weekly/issues/436">精读《对前端架构的理解- 分层与抽象》· Issue #436 · dt-fe/weekly</a></p></blockquote><p><strong>如果你想参与讨论，请 <ahref="https://github.com/dt-fe/weekly">点击这里</a>，每周都有新的主题，周末或周一发布。前端精读- 帮你筛选靠谱的内容。</strong></p><blockquote><p>关注 <strong>前端精读微信公众号</strong></p></blockquote><figure><img src="公众号二维码.jpg" alt="公众号二维码" /><figcaption aria-hidden="true">公众号二维码</figcaption></figure><blockquote><p>版权声明：自由转载-非商用-非衍生-保持署名（<ahref="https://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh">创意共享3.0 许可证</a>）</p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>cookie、session、localStorage、sessionStorage、token 的区别</title>
    <link href="/2022/05/02/cookie%E3%80%81session%E3%80%81localStorage%E3%80%81sessionStorage%E3%80%81token%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2022/05/02/cookie%E3%80%81session%E3%80%81localStorage%E3%80%81sessionStorage%E3%80%81token%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<p>区分 cookie、session、localStorage、sessionStorage、token的概念、工作机制、应用场景以及异同点</p><span id="more"></span><h1id="cookiesessionlocalstoragesessionstoragetoken-的区别">cookie、session、localStorage、sessionStorage、token的区别</h1><h2 id="先避坑">先避坑</h2><ul><li>这里的 token 和上述的几个概念不是同一种东西，token是一种方法/手段。</li><li>localStorage 和 sessionStorage 统称 webStorage，是 html5中提出来的，存粹为了保存数据，不会与服务端通信。</li></ul><h2 id="概念">概念</h2><blockquote><p>HTTP 协议本身是无状态的。什么是无状态呢，即服务器无法判断用户身份</p></blockquote><ul><li><p><strong>cookie</strong> ——它实际上是一小段的<strong>文本信息</strong>（key-value格式），它的大小限制在 4KB左右。当客户端向服务器发起请求，如果服务器需要记录该用户状态，就使用response 向客户端浏览器发送一个 cookie。客户端浏览器会把 cookie保存起来。当浏览器再请求该网站时，浏览器把请求的网址连同该 cookie一同提交给服务器。服务器检查该cookie，以此来<strong>辨认用户状态</strong>。</p></li><li><p><strong>session</strong> ——是另一种记录客户状态的机制，保存在服务器中，<strong>相当于程序在服务器上建立的一份用户的档案，用户来访的时候只需要查询用户档案表就可以了。</strong></p></li><li><p><strong>webStorage</strong> —— 本地存储，存储在客户端，包括<code>localStorage</code> 和<code>sessionStorage</code>。存放数据一般大小为5MB，而且它仅在客户端（即浏览器）中保存，<strong>不参与和服务器的通信</strong>。</p><ul><li><strong>localStorage</strong> ——数据会<strong>永久保存</strong>在客户端中，直到用户自己清除 localStorage信息。</li><li><strong>sessionStorage</strong> ——数据存储<strong>仅在当前会话下有效</strong>，关闭页面或浏览器后它将被清除。</li></ul></li><li><p><strong>token</strong> —— token的意思是<strong>令牌</strong>，是服务端生成的<strong>一串字符串</strong>，作为客户端进行请求的一个标识。</p></li></ul><h2 id="工作机制">工作机制</h2><h3 id="cookie">cookie</h3><p>当用户第一次访问并登录一个网站的时候，cookie 的设置以及发送会经历以下4 个步骤：</p><ol type="1"><li>客户端发送一个请求给服务器</li><li>服务器返回一个 <code>HttpResponse</code> 给客户端，其中包含<code>Set-Cookie</code> 的头部</li><li>客户端保存<strong>cookie</strong>，之后向服务器发送请求时，<code>HttpRequest</code>请求中会包含一个 <strong>cookie</strong> 的头部</li><li>服务器返回响应数据</li></ol><h3 id="session">session</h3><blockquote><p>session 的工作机制离不开 cookie</p></blockquote><p>虽然 session保存在服务器，但是它的正常运行仍然需要客户端浏览器的支持。这是因为session 需要使用 cookie 作为识别标志。</p><p>HTTP 协议是无状态的，session 不能依据 HTTP连接来判断是否为同一客户，<strong>因此服务器向客户端浏览器发送一个名为<code>SESSIONID</code> 的 cookie，它的值为该 Session 的id</strong>。Session 依据该 cookie 来识别是否为同一用户。</p><p>对于不支持 cookie 的手机浏览器，有另一种解决方案：URL地址重写。<strong>URL 地址重写的原理是将该用户 session 的 id 信息重写到URL 地址中，服务器能够解析重写后的 URL 获取 session 的id</strong>。这样即使客户端不支持 cookie，也可以使用 session来记录用户状态。</p><h3 id="webstorage">webStorage</h3><p>提供一种在 cookie之外存储会话数据的路径，提供一种存储大量跨会话存在的数据的机制。cookie为 4KB，而 webStorage 是 5MB。</p><p>webStorage 存储在本地的数据可以直接获取，速度快，并且不会随着 httpheader 发送到服务器端。</p><h4 id="localstorage">localStorage</h4><p>localStorage 的生命周期是永久保存。</p><p>相同浏览器的不同页面间可以共享相同的localStorage（页面属于相同域名和端口）。</p><blockquote><p>localStorage 在所有同源窗口中都是共享的。</p></blockquote><h4 id="sessionstorage">sessionStorage</h4><p>sessionStorage 的生命周期是仅在当前浏览器窗口关闭前有效。</p><p>相同浏览器的不同页面或标签间无法共享 sessionStorage 的信息。</p><blockquote><p>sessionStorage是在同源的窗口中始终存在的数据。只要这个浏览器窗口没有关闭，即使刷新页面或者进入同源另一个页面，数据依然存在。但是sessionStorage在关闭了浏览器窗口后就会被销毁。同时独立的打开同一个窗口同一个页面，sessionStorage也是不一样的。</p><p>注意的是如果在一个标签页中包含多个 iframe标签且他们属于同源页面，那么他们之间是可以共享 sessionStorage 的。</p></blockquote><h4 id="token">token</h4><blockquote><p>当用户第一次登录后，服务器生成一个 token 并将此 token返回给客户端，以后客户端只需带上这个 token来请求数据即可，无需再次带上用户名和密码。</p><p>简单 token 的组成；uid (用户唯一的身份标识)、time(当前时间的时间戳)、sign（签名，token的前几位以哈希算法压缩成的一定长度的十六进制字符串，为防止 token泄露）。</p></blockquote><p>用户在登录时，客户端会发送加密的用户名和密码到服务器，服务器验证用户名和密码，如果验证成功，就会生成相应位数的字符产作为token 存储到服务器中，并且将该 token 返回给客户端。</p><p>以后客户端再次请求时，凡是需要验证的地方都要带上该token，然后服务器端验证token，成功返回所需要的结果，失败返回错误信息，让用户重新登录。其中，服务器上会给token 设置一个有效期，每次 APP 请求的时候都验证 token 和有效期。</p><p><strong>注意：在网络层面上 token使用明文传输的话是非常危险的，所以一定要使用 HTTPS 协议。</strong></p><h2 id="应用场景">应用场景</h2><ul><li><strong>cookie</strong> —— 判断用户是否已登录，仅支持浏览器，不支持app 端</li><li><strong>session</strong> ——把客户端信息以某种形式记录在服务器上，如用户的登录信息</li><li><strong>localStorage</strong> —— 常用于长期登录（+判断用户是否已登录），适合长期保存在本地的数据</li><li><strong>sessionStorage</strong> —— 敏感账号一次性登录</li><li><strong>token</strong> —— 基于 token令牌的身份校验，需要防止防跨站请求伪造（CSRF）攻击的场景</li></ul><h2 id="异同点">异同点</h2><table><thead><tr class="header"><th></th><th>cookie</th><th>session</th><th>localStorage</th><th>sessionStorage</th></tr></thead><tbody><tr class="odd"><td>数据的生命期</td><td>一般由服务器生成，可设置失效时间。如果在浏览器端生成Cookie，默认是关闭浏览器后失效</td><td>在超时时间前访问没有访问服务器，session 就会自动失效</td><td>除非被清除，否则永久保存</td><td>仅在当前会话下有效，关闭页面或浏览器后被清除</td></tr><tr class="even"><td>存放数据大小</td><td>4K 左右</td><td>无限制，但为了减少服务器压力，应该尽量小</td><td>一般为 5MB</td><td>一般为 5MB</td></tr><tr class="odd"><td>与服务器端通信</td><td>每次都会携带在 HTTP 头中，如果使用 cookie保存过多数据会带来性能问题</td><td>保存在服务器端</td><td>仅在客户端（即浏览器）中保存，不参与和服务器的通信</td><td>仅在客户端（即浏览器）中保存，不参与和服务器的通信</td></tr><tr class="even"><td>易用性</td><td>需要程序员自己封装，源生的 Cookie 接口不友好</td><td>后端再次封装</td><td>源生接口可以接受，亦可再次封装来对 Object 和 Array 有更好的支持</td><td>源生接口可以接受，亦可再次封装来对 Object 和 Array 有更好的支持</td></tr></tbody></table><h2 id="参考文章">参考文章</h2><p><ahref="https://blog.csdn.net/jiang7701037/article/details/89118086">面试题：请问cookie，localStorage，sessionStorage 的区别_田江的博客 - CSDN博客</a></p><p><a href="https://jerryzou.com/posts/cookie-and-web-storage/">详说Cookie, LocalStorage 与 SessionStorage | 咀嚼之味 (jerryzou.com)</a></p><p><ahref="https://segmentfault.com/a/1190000039670664">Cookie、Session、localStorage、sessionStorage区别和用法 - SegmentFault 思否</a></p><p><ahref="https://blog.csdn.net/qq_22078107/article/details/87871252">简单理解token 的作用及实现原理_蔡小波的博客 - CSDN 博客</a></p>]]></content>
    
    
    <categories>
      
      <category>大前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>详述SSH的原理及其应用</title>
    <link href="/2022/04/27/%E8%AF%A6%E8%BF%B0SSH%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/"/>
    <url>/2022/04/27/%E8%AF%A6%E8%BF%B0SSH%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>详解 SSH 的定义及原理，具体用法及其应用场景</p><span id="more"></span><h1 id="详述-ssh-的原理及其应用">详述 SSH 的原理及其应用</h1><h2 id="简介">简介</h2><p>SSH（安全外壳协议，Secure Shell 的缩写）由 IETF 的网络小组（NetworkWorking Group）所制定，是建立在应用层基础上的安全协议。</p><p>SSH是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议，利用 SSH协议可以有效防止远程管理过程中的信息泄露问题。</p><p>SSH 最初是 UNIX 系统上的一个程序，后来又迅速扩展到其他操作平台。SSH客户端适用于多种平台，几乎所有 UNIX 平台都可运行 SSH。</p><h2 id="作用">作用</h2><p>传统的网络服务程序，如：FTP、POP 和 Telnet在本质上都是不安全的，因为它们在网络上用明文传送口令和数据，别有用心的人非常容易就可以截获这些口令和数据。而且，这些服务程序的安全验证方式也是有其弱点的，就是很容易受到 “中间人攻击”（Man-in-the-middle attack）。</p><blockquote><p>所谓 “中间人攻击”， 就是“中间人”冒充真正的服务器接收你传给服务器的数据，然后再冒充你把数据传给真正的服务器。服务器和你之间的数据传送被“中间人” 一转手做了手脚之后，就会出现很严重的问题。</p><p>通过使用SSH，你可以把所有传输的数据进行加密，这样”中间人”这种攻击方式就不可能实现了，而且也能够防止DNS 欺骗和 IP 欺骗。使用SSH，还有一个额外的好处就是传输的数据是经过压缩的，所以可以加快传输的速度。</p></blockquote><h2 id="层次">层次</h2><p>SSH 主要由三部分组成：<strong>传输层协议[SSH-TRANS]</strong>、<strong>用户认证协议 [SSH-USERAUTH]</strong>和<strong>连接协议 [SSH-CONNECT]</strong> 组成。</p><ul><li><p><strong>传输层协议[SSH-TRANS]</strong>：提供了服务器认证，保密性及完整性。此外它有时还提供压缩功能。SSH-TRANS 通常运行在 TCP/IP 连接上，也可能用于其它可靠数据流上。SSH-TRANS提供了强力的加密技术、密码主机认证及完整性保护。该协议中的认证基于主机，并且该协议不执行用户认证。更高层的用户认证协议可以设计为在此协议之上。</p></li><li><p><strong>用户认证协议[SSH-USERAUTH]</strong>：用于向服务器提供客户端用户鉴别功能，它运行在传输层协议SSH-TRANS 上面。当 SSH-USERAUTH开始后，它从低层协议那里接收会话标识符，会话标识符唯一标识此会话并且适用于标记以证明私钥的所有权。SSH-USERAUTH 也需要知道低层协议是否提供保密性保护。</p></li><li><p><strong>连接协议[SSH-CONNECT]</strong>：将多个加密隧道分成逻辑通道。它运行在用户认证协议上。它提供了交互式登录话路、远程命令执行、转发TCP/IP 连接和转发 X11 连接。</p></li></ul><h2 id="用法">用法</h2><h3 id="基本操作">基本操作</h3><p>SSH主要用于远程登录。假定我们要以用户名<code>user</code>，登录远程主机<code>host</code>，只要一条简单命令就可以啦！</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">ssh user@host</span><br></code></pre></td></tr></table></figure><p>如果本地用户名与远程用户名一致，登录时可以省略用户名。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">ssh host</span><br></code></pre></td></tr></table></figure><p>SSH的默认端口是<code>22</code>，也就是说，我们的登录请求会送进远程主机的<code>22</code>端口。使用<code>p</code>参数，可以修改这个端口。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">ssh -p 2222 user@host</span><br></code></pre></td></tr></table></figure><p>上面这条命令表示，SSH 直接连接远程主机的<code>2222</code>端口。</p><h3 id="口令登录">口令登录</h3><p>如果我们是第一次登录对方主机，系统会出现下面的提示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">ssh user@host</span><br>The authenticity of host &#x27;host (12.18.81.21)&#x27; can&#x27;t be established.<br>RSA key fingerprint is 98:2e:d7:e0:de:9f:ac:67:28:c2:42:2d:37:16:58:4d.<br>Are you sure you want to continue connecting (yes/no)?<br></code></pre></td></tr></table></figure><p>这段话的意思是，无法确认 host主机的真实性，只知道它的公钥指纹，问你还想继续连接吗？</p><p>所谓” <strong>公钥指纹</strong>”，是指公钥长度较长（这里采用 RSA算法，长达 1024 位），很难比对，所以对其进行 MD5 计算，将它变成一个 128位的指纹。上例中是<code>98:2e:d7:e0:de:9f:ac:67:28:c2:42:2d:37:16:58:4d</code>，再进行比较，就容易多啦！很自然想到的一个问题就是，用户怎么知道远程主机的公钥指纹应该是多少？回答是没有好办法，远程主机必须在自己的网站上贴出公钥指纹，以便用户自行核对。假定经过风险衡量以后，用户决定接受这个远程主机的公钥。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">Are you sure you want to continue connecting (yes/no)? yes<br></code></pre></td></tr></table></figure><p>系统会出现一句提示，表示 host 主机已经得到认可。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">Warning: Permanently added &#x27;host,12.18.429.21&#x27; (RSA) to the list of known hosts.<br></code></pre></td></tr></table></figure><p>然后，会要求输入密码。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">Password: (enter password)<br></code></pre></td></tr></table></figure><p>如果密码正确，就可以登录了。</p><p>当远程主机的公钥被接受以后，它就会被保存在文件<code>$HOME/.ssh/known_hosts</code>之中。下次再连接这台主机，系统就会认出它的公钥已经保存在本地了，从而跳过警告部分，直接提示输入密码。每个SSH用户都有自己的<code>known_hosts</code>文件，此外系统也有一个这样的文件，通常是<code>/etc/ssh/ssh_known_hosts</code>，保存一些对所有用户都可信赖的远程主机的公钥。</p><h3 id="公钥登录">公钥登录</h3><p>使用密码登录，每次都必须输入密码，非常麻烦。好在 SSH还提供了公钥登录，可以省去输入密码的步骤。</p><p>所谓”公钥登录”，原理很简单，就是用户将自己的公钥储存在远程主机上。登录的时候，远程主机会向用户发送一段随机字符串，用户用自己的私钥加密后，再发回来。远程主机用事先储存的公钥进行解密，如果成功，就证明用户是可信的，直接允许登录shell，不再要求密码。这种方法要求用户必须提供自己的公钥。如果没有现成的，可以直接用<code>ssh-keygen</code>生成一个：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">ssh-keygen</span><br></code></pre></td></tr></table></figure><p>运行上面的命令以后，系统会出现一系列提示，可以一路回车。其中有一个问题是，要不要对私钥设置口令（passphrase），如果担心私钥的安全，这里可以设置一个。运行结束以后，在<code>$HOME/.ssh/</code>目录下，会新生成两个文件：<code>id_rsa.pub</code>和<code>id_rsa</code>。前者是你的公钥，后者是你的私钥。这时再输入下面的命令，将公钥传送到远程主机host 上面：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">ssh-copy-id user@host</span><br></code></pre></td></tr></table></figure><p>好了，从此我们再登录，就不需要输入密码了。如果还是不行，就打开远程主机的<code>/etc/ssh/sshd_config</code>这个文件，检查下面几行前面<code>#</code>注释是否取掉。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">RSAAuthentication yes<br>PubkeyAuthentication yes<br>AuthorizedKeysFile .ssh/authorized_keys<br></code></pre></td></tr></table></figure><p>然后，重启远程主机的 SSH 服务。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">/* ubuntu系统 */<br>service ssh restart<br>/* debian系统 */<br>/etc/init.d/ssh restart<br></code></pre></td></tr></table></figure><h3 id="authorized_keys-文件">authorized_keys 文件</h3><p>远程主机将用户的公钥，保存在登录后的用户主目录的<code>$HOME/.ssh/authorized_keys</code>文件中。公钥就是一段字符串，只要把它追加在<code>authorized_keys</code>文件的末尾就行了。这里不使用上面的<code>ssh-copy-id</code>命令，改用下面的命令，解释公钥的保存过程：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">ssh user@host <span class="hljs-string">&#x27;mkdir -p .ssh &amp;&amp; cat &gt;&gt; .ssh/authorized_keys&#x27;</span> &lt; ~/.ssh/id_rsa.pub</span><br></code></pre></td></tr></table></figure><p>这条命令由多个语句组成，依次分解开来看：</p><ul><li><code>$ ssh user@host</code>，表示登录远程主机；</li><li>单引号中的<code>mkdir .ssh &amp;&amp; cat &gt;&gt; .ssh/authorized_keys</code>，表示登录后在远程Shell 上执行的命令：</li><li><code>$ mkdir -p .ssh"的作用是，如果用户主目录中的</code>.ssh`目录不存在，就创建一个；</li><li><code>cat &gt;&gt; .ssh/authorized_keys &lt; ~/.ssh/id_rsa.pub</code>的作用是，将本地的公钥文件<code>~/.ssh/id_rsa.pub</code>，重定向追加到远程文件<code>authorized_keys</code>的末尾。</li></ul><p>写入<code>authorized_keys</code>文件后，公钥登录的设置就完成啦！</p><h3 id="绑定本地端口">绑定本地端口</h3><p>既然 SSH 可以传送数据，那么我们可以让那些不加密的网络连接，全部改走SSH连接，从而提高安全性。假定我们要让<code>8080</code>端口的数据，都通过SSH 传向远程主机，命令就这样写：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">ssh -D 8080 user@host</span><br></code></pre></td></tr></table></figure><p>SSH 会建立一个Socket，去监听本地的<code>8080</code>端口。一旦有数据传向那个端口，就自动把它转移到SSH连接上面，发往远程主机。可以想象，如果<code>8080</code>端口原来是一个不加密端口，现在将变成一个加密端口。</p><h3 id="本地端口转发">本地端口转发</h3><p>有时，绑定本地端口还不够，还必须指定数据传送的目标主机，从而形成点对点的”端口转发”。为了区别后文的” 远程端口转发”，我们把这种情况称为“本地端口转发（Local forwarding）”。</p><p>假定 host1 是本地主机，host2是远程主机。由于种种原因，这两台主机之间无法连通。但是，另外还有一台host3，可以同时连通前面两台主机。因此，很自然的想法就是，通过 host3，将host1 连上 host2。我们在 host1 执行下面的命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">ssh -L 2121:host2:21 host3</span><br></code></pre></td></tr></table></figure><p>命令中的<code>L</code>参数一共接受三个值，分别是<code>本地端口:目标主机:目标主机端口</code>，它们之间用冒号分隔。这条命令的意思，就是指定SSH 绑定本地端口<code>2121</code>，然后指定 host3将所有的数据，转发到目标主机 host2 的<code>21</code>端口（假定 host2运行 FTP，默认端口为<code>21</code>）。这样一来，我们只要连接 host1的<code>2121</code>端口，就等于连上了 host2 的<code>21</code>端口。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">ftp localhost:2121</span><br></code></pre></td></tr></table></figure><p>“本地端口转发” 使得 host1 和 host3之间仿佛形成一个数据传输的秘密隧道，因此又被称为”SSH隧道”。下面是一个比较有趣的例子。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">ssh -L 5900:localhost:5900 host3</span><br></code></pre></td></tr></table></figure><p>它表示将本机的<code>5900</code>端口绑定 host3的<code>5900</code>端口（这里的 localhost 指的是host3，因为目标主机是相对 host3 而言的）。另一个例子是通过 host3的端口转发，SSH 登录 host2。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">ssh -L 9001:host2:22 host3</span><br></code></pre></td></tr></table></figure><p>这时，只要 SSH 登录本机的<code>9001</code>端口，就相当于登录 host2了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">ssh -p 9001 localhost</span><br></code></pre></td></tr></table></figure><p>上面的<code>-p</code>参数表示指定登录端口。</p><h3 id="远程端口转发">远程端口转发</h3><p>既然”本地端口转发”是指绑定本地端口的转发，那么 “远程端口转发（Remoteforwarding）” 当然是指绑定远程端口的转发。</p><p>还是接着看上面那个例子，host1 与 host2 之间无法连通，必须借助 host3转发。但是，特殊情况出现了，host3 是一台内网机器，它可以连接外网的host1，但是反过来就不行，外网的 host1 连不上内网的host3。这时，本地端口转发就不能用了，怎么办？</p><p>解决办法是，既然 host3 可以连 host1，那么就从 host3 上建立与 host1 的SSH 连接，然后在 host1 上使用这条连接就可以了。我们在 host3执行下面的命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">ssh -R 2121:host2:21 host1</span><br></code></pre></td></tr></table></figure><p><code>R</code>参数也是接受三个值，分别是<code>远程主机端口:目标主机:目标主机端口</code>。这条命令的意思，就是让host1 监听它自己的<code>2121</code>端口，然后将所有数据经由host3，转发到 host2 的<code>21</code>端口。由于对于 host3 来说，host1是远程主机，所以这种情况就被称为远程端口绑定。绑定之后，我们在 host1就可以连接 host2 了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">ftp localhost:2121</span><br></code></pre></td></tr></table></figure><p>这里必须指出，远程端口转发的前提条件是，host1 和 host3 两台主机都有sshD 和 SSH 客户端。</p><h3 id="ssh-的其他参数">SSH 的其他参数</h3><p>SSH还有一些别的参数，也值得介绍。<code>N</code>参数，表示只连接远程主机，不打开远程Shell；<code>T</code>参数，表示不为这个连接分配TTY。这个两个参数可以放在一起用，代表这个 SSH连接只用来传数据，不执行远程操作。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">ssh -NT -D 8080 host</span><br></code></pre></td></tr></table></figure><p><code>f</code>参数，表示 SSH连接成功后，转入后台运行。这样一来，你就可以在不中断 SSH连接的情况下，在本地 Shell 中执行其他操作。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">ssh -f -D 8080 host</span><br></code></pre></td></tr></table></figure><p>要关闭这个后台连接，只能用<code>kill</code>命令去杀掉进程。</p><hr /><h2 id="参考资料">参考资料</h2><p><ahref="http://baike.baidu.com/link?url=FBYD3gt-oTCm9Zis_6_LRDd6I86AWeHbmW5hiU9YeU8UUMR8QzSGL27FegWLcQ-iMmCs3aaRBAWDJ6FyHMha7K">ssh（安全外壳协议）- 百度百科</a> <ahref="http://www.ruanyifeng.com/blog/2011/12/ssh_remote_login.html">ssh原理与应用（一）：远程登录 - 阮一峰的网络日志</a> <ahref="http://www.ruanyifeng.com/blog/2011/12/ssh_port_forwarding.html">ssh原理与应用（二）：远程操作与端口转发 - 阮一峰的网络日志</a></p>]]></content>
    
    
    <categories>
      
      <category>教程</category>
      
      <category>VPS常见问题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Shell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>快速搞定防抖节流函数</title>
    <link href="/2022/04/27/%E5%BF%AB%E9%80%9F%E6%90%9E%E5%AE%9A%E9%98%B2%E6%8A%96%E8%8A%82%E6%B5%81%E5%87%BD%E6%95%B0/"/>
    <url>/2022/04/27/%E5%BF%AB%E9%80%9F%E6%90%9E%E5%AE%9A%E9%98%B2%E6%8A%96%E8%8A%82%E6%B5%81%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p>防抖函数和节流函数的定义、具体实现、应用场景和异同点</p><span id="more"></span><h1 id="防抖节流函数">防抖节流函数</h1><h2 id="是什么">是什么</h2><p><strong>防抖函数(debounce)</strong>：n 秒后在执行该事件，若在 n秒内被重复触发，则重新计时</p><p><strong>节流函数(throttle)</strong>：n 秒内只运行一次，若在 n秒内重复触发，只有一次生效</p><h2 id="为什么要防抖节流函数">为什么要防抖节流函数</h2><p>本质上是优化高频率执行代码的一种手段，对浪费资源的事件采取限制调用次数的限制</p><h3 id="常见应用场景">常见应用场景</h3><p><strong>防抖</strong>在连续的事件，只需触发一次回调的场景有：</p><ul><li>搜索框搜索输入。只需用户最后一次输入完，再发送请求</li><li>手机号、邮箱验证输入检测</li><li>窗口大小<code>resize</code>。只需窗口调整完成后，计算窗口大小。防止重复渲染。</li></ul><p><strong>节流</strong>在间隔一段时间执行一次回调的场景有：</p><ul><li>滚动加载，加载更多或滚到底部监听</li><li>搜索框，搜索联想功能</li></ul><h2 id="代码实现">代码实现</h2><h3 id="防抖">防抖</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">debounce</span>(<span class="hljs-params">func, wait</span>) &#123;<br>  <span class="hljs-keyword">let</span> timeout;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">let</span> context = <span class="hljs-variable language_">this</span>; <span class="hljs-comment">// 保存this指向</span><br>    <span class="hljs-keyword">let</span> args = <span class="hljs-variable language_">arguments</span>; <span class="hljs-comment">// 拿到event对象</span><br><br>    <span class="hljs-built_in">clearTimeout</span>(timeout);<br>    timeout = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>      func.<span class="hljs-title function_">apply</span>(context, args);<br>    &#125;, wait);<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>防抖如果需要立即执行，可加入第三个参数用于判断，实现如下:</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">debounce</span>(<span class="hljs-params">func, wait, immediate</span>) &#123;<br>  <span class="hljs-keyword">let</span> timeout;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">let</span> context = <span class="hljs-variable language_">this</span>;<br>    <span class="hljs-keyword">let</span> args = <span class="hljs-variable language_">arguments</span>;<br><br>    <span class="hljs-keyword">if</span> (timeout) <span class="hljs-built_in">clearTimeout</span>(timeout); <span class="hljs-comment">// timeout 不为null</span><br>    <span class="hljs-keyword">if</span> (immediate) &#123;<br>      <span class="hljs-keyword">let</span> callNow = !timeout; <span class="hljs-comment">// 第一次会立即执行，以后只有事件执行后才会再次触发</span><br>      timeout = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        timeout = <span class="hljs-literal">null</span>;<br>      &#125;, wait);<br>      <span class="hljs-keyword">if</span> (callNow) &#123;<br>        func.<span class="hljs-title function_">apply</span>(context, args);<br>      &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      timeout = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        func.<span class="hljs-title function_">apply</span>(context, args);<br>      &#125;, wait);<br>    &#125;<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="节流">节流</h3><blockquote><p>利用定时器实现节流函数:</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">throttled</span>(<span class="hljs-params">fn, delay = <span class="hljs-number">500</span></span>) &#123;<br>  <span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">...args</span>) &#123;<br>    <span class="hljs-keyword">if</span> (!timer) &#123;<br>      timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        fn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args);<br>        timer = <span class="hljs-literal">null</span>;<br>      &#125;, delay);<br>    &#125;<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>利用时间戳实现节流函数，时间会立即执行，停止触发后没办法再次执行:</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">throttled</span>(<span class="hljs-params">fn, delay = <span class="hljs-number">500</span></span>) &#123;<br>  <span class="hljs-keyword">let</span> oldTime = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>();<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">...args</span>) &#123;<br>    <span class="hljs-keyword">let</span> newTime = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>();<br>    <span class="hljs-keyword">if</span> (newTime - oldTime &gt;= delay) &#123;<br>      fn.<span class="hljs-title function_">apply</span>(<span class="hljs-literal">null</span>, args);<br>      oldTime = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>();<br>    &#125;<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>将时间戳写法的特性与定时器写法的特性相结合，更精确:</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">throttled</span>(<span class="hljs-params">fn, delay</span>) &#123;<br>  <span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span>;<br>  <span class="hljs-keyword">let</span> startTime = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>();<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">let</span> curTime = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>(); <span class="hljs-comment">// 当前时间</span><br>    <span class="hljs-keyword">let</span> remaining = delay - (curTime - startTime); <span class="hljs-comment">// 从上一次到现在，还剩下多少多余时间</span><br>    <span class="hljs-keyword">let</span> context = <span class="hljs-variable language_">this</span>;<br>    <span class="hljs-keyword">let</span> args = <span class="hljs-variable language_">arguments</span>;<br>    <span class="hljs-built_in">clearTimeout</span>(timer);<br>    <span class="hljs-keyword">if</span> (remaining &lt;= <span class="hljs-number">0</span>) &#123;<br>      fn.<span class="hljs-title function_">apply</span>(context, args);<br>      startTime = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      timer = <span class="hljs-built_in">setTimeout</span>(fn, remaining);<br>    &#125;<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="总结">总结</h2><h3 id="相同点">相同点</h3><ul><li>都可以通过使用 <code>setTimeout</code> 实现</li><li>目的都是，降低回调执行频率。节省计算资源</li></ul><h3 id="不同点">不同点</h3><table><thead><tr class="header"><th>函数防抖</th><th>函数节流</th></tr></thead><tbody><tr class="odd"><td>在一段连续操作结束后，处理回调，<strong>利用<code>clearTimeout</code> 和 <code>setTimeout</code> 实现</strong></td><td>在一段连续操作中，<strong>每一段时间只执行一次</strong>，频率较高的事件中使用来提高性能</td></tr><tr class="even"><td>希望一定时间连续触发的事件<strong>只在最后执行一次</strong></td><td>希望一定时间连续触发的事件<strong>一段时间内只执行一次</strong></td></tr></tbody></table><h2 id="参考文章">参考文章</h2><p><ahref="https://vue3js.cn/interview/JavaScript/debounce_throttle.html">面试官：什么是防抖和节流？有什么区别？如何实现？</a></p><p><ahref="https://segmentfault.com/a/1190000018445196">彻底弄懂函数防抖和函数节流- SegmentFault 思否</a></p>]]></content>
    
    
    <categories>
      
      <category>大前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Rust开发环境搭建</title>
    <link href="/2020/11/07/Rust%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <url>/2020/11/07/Rust%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<p>为了让本地的环境更加干净便于管理，我正逐渐地把开发环境转移到wsl2中，win环境仅用来作游戏机和一些剪辑工作</p><span id="more"></span><h2 id="下载安装">下载安装</h2><p><ahref="https://www.rust-lang.org/zh-CN/">Rust官网</a>中已经写得很详细了，这是我见过的编程语言中最漂亮的官网，而且官方文档也写得非常好，根据指引操作即可。</p><p>安装Rust主要有两种方式，第一种下载 Rustup安装器并安装MSVC，第二种通过命令行下载。</p><p>这里我选择更方便的命令行方式以便安装在 wsl2 中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 设置临时镜像加速，使用代理则不需要</span><br><span class="hljs-built_in">export</span> RUSTUP_DIST_SERVER=https://mirrors.ustc.edu.cn/rust-static<br><span class="hljs-built_in">export</span> RUSTUP_UPDATE_ROOT=https://mirrors.ustc.edu.cn/rust-static/rustup<br><br><span class="hljs-comment"># 如果在 WSL1 环境下，可能需要设置这个</span><br><span class="hljs-built_in">export</span> RUSTUP_IO_THREADS=1<br><br><span class="hljs-comment"># 官网提供的安装命令</span><br>curl --proto <span class="hljs-string">&#x27;=https&#x27;</span> --tlsv1.2 -sSf https://sh.rustup.rs | sh<br></code></pre></td></tr></table></figure><p>根据指引安装，我选择默认的<kbd>1</kbd></p><blockquote><p>在 Rust 开发环境中，所有工具都安装在 <code>~/.cargo/bin</code>目录中，您可以在这里找到包括 <code>rustc</code>、<code>cargo</code> 和<code>rustup</code> 在内的 Rust 工具链。</p></blockquote><h2 id="更改镜像源">更改镜像源</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs bash">[source.crates-io]<br>registry = <span class="hljs-string">&quot;https://github.com/rust-lang/crates.io-index&quot;</span><br><br><span class="hljs-comment"># 替换成你偏好的镜像源</span><br>replace-with = <span class="hljs-string">&#x27;rustcc&#x27;</span><br><br><span class="hljs-comment"># rustcc 1号源</span><br>[source.rustcc]<br>registry=<span class="hljs-string">&quot;git://crates.rustcc.com/crates.io-index&quot;</span><br><br><span class="hljs-comment"># rustcc 2号源</span><br>[source.rustcc2]<br>registry=<span class="hljs-string">&quot;git://crates.rustcc.cn/crates.io-index&quot;</span><br><br><span class="hljs-comment"># 清华大学</span><br>[source.tuna]<br>registry = <span class="hljs-string">&quot;https://mirrors.tuna.tsinghua.edu.cn/git/crates.io-index.git&quot;</span><br><br><span class="hljs-comment"># 中国科学技术大学</span><br>[source.ustc]<br>registry = <span class="hljs-string">&quot;git://mirrors.ustc.edu.cn/crates.io-index&quot;</span><br><br><span class="hljs-comment"># 上海交通大学</span><br>[source.sjtu]<br>registry = <span class="hljs-string">&quot;https://mirrors.sjtug.sjtu.edu.cn/git/crates.io-index&quot;</span><br><br>[net]<br>git-fetch-with-cli = <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><h2 id="hello-world">Hello World</h2><h3 id="cargo">Cargo</h3><p>在安装 Rustup 时，会同时安装 Rust 构建工具和包管理器的最新稳定版，即Cargo</p><p>检查是否安装了Rust和Cargo，可以在终端中运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cargo --version<br></code></pre></td></tr></table></figure><h2 id="创建一个hello-world">创建一个Hello World</h2><p>在命令行中运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cargo new hello-rust<br></code></pre></td></tr></table></figure><p>当前目录下会生成一个 <code>hello-rust</code> 的新目录，其中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">hello-rust     <br>|- Cargo.toml   <span class="hljs-comment"># 项目的清单</span><br>|- src          <br>  |- main.rs    <span class="hljs-comment"># 编写应用代码的地方</span><br></code></pre></td></tr></table></figure><h2 id="配置vs-code">配置VS Code</h2><h3 id="安装拓展">安装拓展</h3><p>首先安装 <ahref="https://marketplace.visualstudio.com/items?itemName=rust-lang.rust">Rust</a>拓展和 <ahref="https://marketplace.visualstudio.com/items?itemName=matklad.rust-analyzer">rust-analyzer</a>拓展</p><figure><img src="Rust.jpg" alt="Rust" /><figcaption aria-hidden="true">Rust</figcaption></figure><figure><img src="rust-analyzer.jpg" alt="rust-analyzer" /><figcaption aria-hidden="true">rust-analyzer</figcaption></figure><p>安装 <ahref="https://marketplace.visualstudio.com/items?itemName=bungcip.better-toml">BetterTOML</a> 拓展以便支持 <code>.toml</code> 文件语法高亮</p><figure><img src="Better%20TOML.jpg" alt="Better TOML" /><figcaption aria-hidden="true">Better TOML</figcaption></figure><p>为了能在 vs code 上调试 rust 代码，还需安装 <ahref="https://marketplace.visualstudio.com/items?itemName=vadimcn.vscode-lldb">CodeLLDB</a>拓展</p><figure><img src="CodeLLDB.jpg" alt="CodeLLDB" /><figcaption aria-hidden="true">CodeLLDB</figcaption></figure><h3 id="运行hello-rust">运行hello-rust</h3><p>在命令行中运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">code ~/hello-rust <span class="hljs-comment"># 这里注意选择项目所在路径</span><br></code></pre></td></tr></table></figure><p>此时 vs code右下角会出现相应提示，根据提示操作即可，如果没有提示可以尝试先打开<code>src/main.rs</code></p><p>选择 <code>运行</code> → <code>打开配置</code> 此时应该会生成<code>launch.json</code> 文件并打开</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-comment">// 生成的launch.json配置如下 2020.11.07</span><br><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-comment">// 使用 IntelliSense 了解相关属性。 </span><br>    <span class="hljs-comment">// 悬停以查看现有属性的描述。</span><br>    <span class="hljs-comment">// 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387</span><br>    <span class="hljs-attr">&quot;version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;0.2.0&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;configurations&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;lldb&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;request&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;launch&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Debug executable &#x27;hello-rust&#x27;&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;cargo&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>                <span class="hljs-attr">&quot;args&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>                    <span class="hljs-string">&quot;build&quot;</span><span class="hljs-punctuation">,</span><br>                    <span class="hljs-string">&quot;--bin=hello-rust&quot;</span><span class="hljs-punctuation">,</span><br>                    <span class="hljs-string">&quot;--package=hello-rust&quot;</span><br>                <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;filter&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>                    <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;hello-rust&quot;</span><span class="hljs-punctuation">,</span><br>                    <span class="hljs-attr">&quot;kind&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;bin&quot;</span><br>                <span class="hljs-punctuation">&#125;</span><br>            <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;args&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;cwd&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;$&#123;workspaceFolder&#125;&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;lldb&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;request&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;launch&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Debug unit tests in executable &#x27;hello-rust&#x27;&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;cargo&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>                <span class="hljs-attr">&quot;args&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>                    <span class="hljs-string">&quot;test&quot;</span><span class="hljs-punctuation">,</span><br>                    <span class="hljs-string">&quot;--no-run&quot;</span><span class="hljs-punctuation">,</span><br>                    <span class="hljs-string">&quot;--bin=hello-rust&quot;</span><span class="hljs-punctuation">,</span><br>                    <span class="hljs-string">&quot;--package=hello-rust&quot;</span><br>                <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;filter&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>                    <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;hello-rust&quot;</span><span class="hljs-punctuation">,</span><br>                    <span class="hljs-attr">&quot;kind&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;bin&quot;</span><br>                <span class="hljs-punctuation">&#125;</span><br>            <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;args&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;cwd&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;$&#123;workspaceFolder&#125;&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>这时回到 <code>main.rs</code>打断点，按<kbd>F5</kbd>启动调试，假如启动调试失败，观察左下方状态栏，是否未选择LLDB调试：</p><figure><img src="选择LLDB.jpg" alt="选择LLDB" /><figcaption aria-hidden="true">选择LLDB</figcaption></figure><h2 id="卸载rust">卸载Rust</h2><p>执行 <code>rustup self uninstall</code></p>]]></content>
    
    
    <categories>
      
      <category>教程</category>
      
      <category>Rust常见问题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Rust</tag>
      
      <tag>vscode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>自己动手搭建云端IDE</title>
    <link href="/2020/07/09/%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E6%90%AD%E5%BB%BA%E4%BA%91%E7%AB%AFIDE/"/>
    <url>/2020/07/09/%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E6%90%AD%E5%BB%BA%E4%BA%91%E7%AB%AFIDE/</url>
    
    <content type="html"><![CDATA[<p>基于 code-server 搭建一个云端 VS Code，随时随地在浏览器上 Coding</p><span id="more"></span><h2 id="介绍">介绍</h2><p>最近突然想试 <a href="https://github.com/features/codespaces">GitHubCodespaces</a>，无奈测试资格永远在等待。<ahref="https://visualstudio.microsoft.com/zh-hans/services/visual-studio-codespaces/">VisualStudio Codespaces</a>(原 Visual Studio Online)需要付费。<ahref="https://coding.net/products/cloudstudio">Coding</a>以前用过还是类似Idea 的版本，现在变成类似 vscode 的样子，应该还是不错的<del>（我选择GitHub Codespaces）</del>。</p><p>偶然情况下我发现了开源的 <ahref="https://github.com/cdr/code-server">cdr/code-server</a>，只需拥有一台自己的服务器即可实现属于自己的云端IDE。</p><h2 id="准备">准备</h2><h3 id="服务器">服务器</h3><p>我用的是阿里云的学生鸡（1 核 2G，2G 内存，40G 硬盘，1M 带宽）</p><h3 id="下载-tar.gz">下载 tar.gz</h3><blockquote><p>国外或港澳台地区的 vps 可以跳过这一步</p></blockquote><p><a href="https://github.com/cdr/code-server/releases">下载最新版的code server文件</a>，如<code>code-server-3.4.1-linux-x86_64.tar.gz</code></p><h2 id="开始搭建">开始搭建</h2><h3 id="登陆-vps">1.登陆 vps</h3><p>通过 SSH 远程连接服务器或 VNC 登陆</p><h3 id="上传-tar.gz">2.上传 tar.gz</h3><p>各显神通的环节，sftp、pscp…… 我是直接在宝塔面板上传的。</p><p>国外或港澳台地区的 vps 直接执行以下代码下载tar.gz（版本号自行修改成最新版本）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">wget https://github.com/cdr/code-server/releases/download/3.4.1/code-server-3.4.1-linux-x86_64.tar.gz<br></code></pre></td></tr></table></figure><h3 id="解压-tar.gz">3.解压 tar.gz</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">tar xf code-server-3.4.1-linux-x86_64.tar.gz<br></code></pre></td></tr></table></figure><h3 id="安装配置">3.安装配置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 进入解压后的目录</span><br><span class="hljs-built_in">cd</span> code-server-3.1.1-linux-x86_64<br><span class="hljs-comment"># 设置一个登陆密码</span><br><span class="hljs-built_in">export</span> PASSWORD=<span class="hljs-string">&quot;mypassowrd&quot;</span><br><span class="hljs-comment"># 由于code-server默认只能够监听本地地址，也就是 127.0.0.1</span><br><span class="hljs-comment"># 指定监听地址、监听端口并执行code-server</span><br>./code-server --host 0.0.0.0 --port 8080<br></code></pre></td></tr></table></figure><h3 id="服务器防火墙配置">4.服务器防火墙配置</h3><p>进入阿里云<strong>实例安全组</strong>，将 8080 端口打开。</p><h3 id="测试">5.测试</h3><p>在浏览器中输入 {<strong>服务器 IP 地址</strong>}:{<strong>code-server端口</strong>}，并输入刚才设置的密码，进入属于自己的云端 vscode</p><p>安装 vscode 常用插件，如简体中文语言包等。</p><h2 id="one-more-thing">One more thing</h2><p>由于在 Safari浏览器中使用体验比较糟糕，因此通过一款专门为iPad优化的ios应用<ahref="https://servediter.app/">Servediter(原VSApp)</a>来实现在iPad上流畅的云端IDE体验。</p><p>servediter分为付费和免费，搭建在自己服务器上的codeserver只需要使用免费服务即可。</p><h3 id="登陆配置">登陆配置</h3><p>直接选择菜单中的 <strong>Self HostedServer</strong>，然后根据要求填写刚才部署的code-server相关信息。</p><figure><img src="servediter配置.jpg" alt="servediter配置" /><figcaption aria-hidden="true">servediter配置</figcaption></figure><h3 id="效果">效果</h3><figure><img src="servediter效果.jpg" alt="servediter效果" /><figcaption aria-hidden="true">servediter效果</figcaption></figure><h2 id="总结">总结</h2><p>在配合servediter使用的条件下，延迟问题不严重。我认为最大的问题还是受制于vps的性能。在和同类产品对比的情况下，code-server的生产力属性相对逊色，我更倾向于把他当成多平台的笔记类应用，支持vscode的大部分插件、使用自己的vps保障了隐私、用浏览器就能登录使用也足够方便。而如果用于编程，我觉得有点南辕北辙，毕竟专业的事交给更专业的工具去做更好。</p><h2 id="参考文章">参考文章</h2><ul><li><a href="https://brief-rf.gitee.io/code-server/">搭建自己的云端IDE</a></li><li><a href="https://sspai.com/post/60456">为 iPad 部署基于 VS Code的远程开发环境</a></li><li><a href="https://www.bilibili.com/video/BV1Zz411i7rp/">【编程】云端IDE 介绍与搭建教程｜｜新的编程方式增加了！</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>玩具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>vscode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CentOS 7更新git版本</title>
    <link href="/2020/07/06/CentOS%207%E6%9B%B4%E6%96%B0git%E7%89%88%E6%9C%AC/"/>
    <url>/2020/07/06/CentOS%207%E6%9B%B4%E6%96%B0git%E7%89%88%E6%9C%AC/</url>
    
    <content type="html"><![CDATA[<p>CentOS 7 默认 git 版本是 1.8，通过源码编译更新 git 版本</p><span id="more"></span><h1 id="升级-git-版本">升级 git 版本</h1><p>由于 CentOS 7 默认的 repo 和 git 官网都没有提供rpm，那么只有两种方法，1. 通过源码编译，2. 使用第三方的rpm，这里使用第一种方法。</p><h2 id="卸载原有的-git">1. 卸载原有的 git</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum remove git<br></code></pre></td></tr></table></figure><h2 id="安装相关依赖">2. 安装相关依赖</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum -y install zlib-devel curl-devel openssl-devel perl cpio expat-devel gettext-devel openssl zlib autoconf tk perl-ExtUtils-MakeMaker<br></code></pre></td></tr></table></figure><h2 id="获取最新的-git-源码包">3. 获取最新的 git 源码包</h2><p>从<ahref="https://link.jianshu.com/?t=https://github.com/git/git/releases">repo</a>中下载最新稳定版的zip 包或者 tar.gz 并解压。 以 tar.gz 格式为例（在网页的 tar.gz上右键复制下载链接即可）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">wget https://github.com/git/git/archive/v2.27.0.tar.gz<br>tar zxvf v2.27.0.tar.gz<br></code></pre></td></tr></table></figure><p>解压后得到一个 git-2.27.0的目录（版本号与下载的一致），然后进入目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> git-2.27.0<br></code></pre></td></tr></table></figure><h2 id="编译安装">4. 编译安装</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">autoconf<br>./configure<br>make<br>make install<br></code></pre></td></tr></table></figure><p>以上 4 步请一步步来，以免出现错误不好找原因。</p><h2 id="添加到环境变量中">5. 添加到环境变量中</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;export PATH=<span class="hljs-variable">$PATH</span>:/usr/local/git/bin&quot;</span> &gt;&gt; /etc/profile &amp;&amp; <span class="hljs-built_in">source</span> /etc/profile<br></code></pre></td></tr></table></figure><h2 id="查看当前-git-版本">6.查看当前 git 版本</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git --version<br></code></pre></td></tr></table></figure><h1 id="参考文章">参考文章</h1><ul><li><a href="https://www.jianshu.com/p/cae9a3b02d9d">CentOS 7 升级Git</a></li><li><a href="https://juejin.im/post/5dae627751882568a71eed5d">Centos7升级 Git 版本</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>教程</category>
      
      <category>VPS常见问题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>CentOS</tag>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>博客功能测试</title>
    <link href="/2020/05/27/%E5%8D%9A%E5%AE%A2%E5%8A%9F%E8%83%BD%E6%B5%8B%E8%AF%95/"/>
    <url>/2020/05/27/%E5%8D%9A%E5%AE%A2%E5%8A%9F%E8%83%BD%E6%B5%8B%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<p>本文章用于测试博客中的各种功能。</p><span id="more"></span><h1 id="部署优化">部署优化</h1><h2 id="利用-git-branch-管理-hexo-源文件">利用 git branch 管理 hexo源文件</h2><p>新建一个 source 分支用于存储 hexo 源文件，master 分支存储生成后的html,css,js 文件。 已完成</p><h2 id="利用-vercel原-zeit-托管静态页面">利用 Vercel(原 Zeit)托管静态页面</h2><p>已完成</p><h2 id="图床测试">图床测试</h2><h3 id="直接存放在网站中通过-vercel-的-cdn-加速">直接存放在网站中,通过Vercel 的 CDN 加速</h3><figure><img src="default.jpg" alt="default.jpg" /><figcaption aria-hidden="true">default.jpg</figcaption></figure><h3 id="使用路过图床">使用<ahref="https://imgchr.com/">路过图床</a></h3><figure><img src="https://s1.ax1x.com/2020/06/05/tr45m4.jpg" alt="tr45m4.jpg" /><figcaption aria-hidden="true">tr45m4.jpg</figcaption></figure><h3 id="速度对比">速度对比</h3><blockquote><p>左为部署在网站中 右为使用图床</p></blockquote><h4 id="傍晚速度1800">傍晚速度(18:00)</h4><figure><img src="傍晚速度.jpg" alt="傍晚速度" /><figcaption aria-hidden="true">傍晚速度</figcaption></figure><h4 id="晚上速度2100">晚上速度(21:00)</h4><figure><img src="晚上速度.jpg" alt="晚上速度" /><figcaption aria-hidden="true">晚上速度</figcaption></figure><h1 id="页面相关功能">页面相关功能</h1><h2 id="代码块样式---mac-panel">代码块样式 - mac panel</h2><p>TODO</p><h2 id="数学公式---mathjax">数学公式 - MathJax</h2><h3 id="方程组">方程组</h3><p><span class="math display">\[\begin{equation}\label{2}   \begin{cases}   x_n=b_n^{(n)}/a_{nn}^{(n)},\\\\   x_i=(b_i^{(i)}-\sum\limits_{j=i+1}^n{a_{ij}^{(i)}x_j})/a_{ii}^{(i)}   \end{cases}\end{equation}\]</span></p><h3 id="公式换行">公式换行</h3><p><span class="math display">\[\begin{equation}　\begin{aligned}　　f(x)&amp;=f(x_0)+f[x_0,x_1](x-x_0)+f[x_0,x_1，x_2](x-x_0)(x-x_1)+\cdot\cdot\cdot\\\&amp;\ \ \ \ \ \+f[x_0,x_1\cdot\cdot\cdot,x_n](x-x_0)\cdot\cdot\cdot(x-x_{n-1}) \\\&amp;\ \ \ \ \ \ +f[x,x_0\cdot\cdot\cdot,x_n]\omega_{n+1}(x) \\\　　&amp; =P_n(x)+R_n(x)　\end{aligned}\end{equation}\]</span></p><h3 id="矩阵">矩阵</h3><p><span class="math display">\[\begin{bmatrix}　　　　3.01 &amp; 6.03 &amp; 1.99 \\\　　　　1.27 &amp; 4.16 &amp; -1.23 \\\　　　　0.987 &amp; -4.81 &amp; 9.34　　　　\end{bmatrix}　　　　\begin{bmatrix}　　　　x_1 \\\ x_2 \\\ x_3　　　　\end{bmatrix} =　　　　\begin{bmatrix}　　　　1 \\\ 1 \\\ 1　　\end{bmatrix}\]</span></p><h2 id="流程图">流程图</h2><h3 id="饼图">饼图</h3><div class="mermaid" width="100%"><pre><code class="hljs">pie title NETFLIX     &quot;Time spent looking for movie&quot; : 90     &quot;Time spent watching it&quot; : 10</code></pre></div><h3 id="序列图">序列图</h3><div class="mermaid" width="100%"><pre><code class="hljs">sequenceDiagram    Alice -&gt;&gt; Bob: Hello Bob, how are you?    Bob--&gt;&gt;John: How about you John?    Bob--x Alice: I am good thanks!    Bob-x John: I am good thanks!    Note right of John: Bob thinks a long&lt;br/&gt;long time, so long&lt;br/&gt;that the text does&lt;br/&gt;not fit on a row.    Bob--&gt;Alice: Checking with John...    Alice-&gt;John: Yes... John, how are you?</code></pre></div><h3 id="较大的流程图">较大的流程图</h3><div class="mermaid" width="100%"><pre><code class="hljs">graph TB    sq[Square shape] --&gt; ci((Circle shape))    subgraph A        od&gt;Odd shape]-- Two line&lt;br/&gt;edge comment --&gt; ro        di&#123;Diamond with &lt;br/&gt; line break&#125; -.-&gt; ro(Rounded&lt;br&gt;square&lt;br&gt;shape)        di==&gt;ro2(Rounded square shape)    end    %% Notice that no text in shape are added here instead that is appended further down    e --&gt; od3&gt;Really long text with linebreak&lt;br&gt;in an Odd shape]    %% Comments after double percent signs    e((Inner / circle&lt;br&gt;and some odd &lt;br&gt;special characters)) --&gt; f(,.?!+-*ز)    cyr[Cyrillic]--&gt;cyr2((Circle shape Начало));    classDef green fill:#9f6,stroke:#333,stroke-width:2px;    classDef orange fill:#f96,stroke:#333,stroke-width:4px;    class sq,e green    class di orange</code></pre></div><h3 id="小结">小结</h3><p>流程图的样式不对，部分较大的流程图会超出页面界限，在 mermaid的说明文档中也存在这样的问题，估计是 mermaid 的 bug，修复需要自己自定义css，比较麻烦。考虑到 markdown 中画流程图的语法也不简单，mermaid 生成的svg图片无法放大，因此弃用，除简单图外，均使用插入图片形式展示流程图。</p><h2 id="iframe-视频播放">iframe 视频播放</h2><iframe src="//player.bilibili.com/player.html?aid=85241895&amp;bvid=BV11741167eC&amp;cid=145722126&amp;page=1" width="100%" height="500" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"></iframe>]]></content>
    
    
    <categories>
      
      <category>博客技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>Fluid</tag>
      
      <tag>Test</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
